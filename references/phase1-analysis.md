# Phase 1: Analysis Reference

## QA_ANALYSIS.md Template

Use exactly this structure. Adapt sections to the project's reality — skip what doesn't apply, add what's specific to the stack discovered.

```markdown
# QA Analysis Report

> Generated by Agent QA — Phase 1
> Project: [name]
> Date: [date]
> Root: [path]

## 1. Project Overview

### 1.1 Tech Stack
| Layer       | Technology     | Version |
|-------------|---------------|---------|
| Language    | ...           | ...     |
| Framework   | ...           | ...     |
| Database    | ...           | ...     |
| Build Tool  | ...           | ...     |
| Test Runner | ...           | ...     |
| CI/CD       | ...           | ...     |

### 1.2 Architecture
- **Pattern**: [MVC / Hexagonal / Microservices / Monolith / etc.]
- **Entry points**: [list main entry files]
- **Key conventions**: [naming, folder structure, coding standards detected]

### 1.3 Dependency Map
[Module dependency graph in text or mermaid format]

### 1.4 External Integrations
| Service      | Type     | Used By       |
|-------------|----------|---------------|
| ...         | API/DB/Queue | module_name |

---

## 2. Module: [module_name]

> Path: `src/module_name/`
> Purpose: [one-line description]
> Dependencies: [list internal dependencies]

### 2.1 Functionality: [functionality_name]

> Entry: `file.ext:function_or_class`
> Flow: [brief description of data flow]

#### Checkpoints

- [ ] **Integration**: All imports/dependencies resolve correctly
- [ ] **Data flow**: Input → processing → output path is complete and correct
- [ ] **Error handling**: Errors are caught, logged, and propagated appropriately
- [ ] **Edge cases**: Null/empty/boundary inputs are handled
- [ ] **Naming**: Variables, functions, classes follow project conventions
- [ ] **Types**: Type annotations/contracts are consistent and correct
- [ ] **Return values**: All code paths return expected types/values
- [ ] **Side effects**: Side effects are intentional and documented
- [ ] **Configuration**: Config values are validated and have sensible defaults
- [ ] **Security**: No hardcoded secrets, SQL injection, XSS, or injection vectors

### 2.2 Functionality: [next_functionality]
...

---

## 3. Module: [next_module]
...

---

## N. Cross-Cutting Concerns

### N.1 Functionality: Error Handling Strategy
- [ ] Consistent error types/classes across modules
- [ ] Error propagation follows a clear pattern
- [ ] User-facing errors are sanitized

### N.2 Functionality: Configuration Management
- [ ] Environment variables are documented
- [ ] Defaults exist for all config values
- [ ] Sensitive config is not committed to source

### N.3 Functionality: Logging & Observability
- [ ] Log levels are used consistently
- [ ] Structured logging where applicable
- [ ] No sensitive data in logs

### N.4 Functionality: Data Validation
- [ ] Input validation at system boundaries
- [ ] Consistent validation patterns
- [ ] Validation errors are informative

### N.5 Functionality: Code Consistency
- [ ] Consistent formatting across files
- [ ] No dead code or unused imports
- [ ] No duplicated logic that should be shared
```

## Analysis Checklist by Category

When building checkpoints for each functionality, draw from these categories as applicable:

### Integration & Dependencies
- Import/require statements resolve
- Dependency versions are compatible
- Circular dependencies don't exist
- External API contracts match usage

### Data Flow
- Input validation exists at entry points
- Data transformations are correct
- Output format matches consumers' expectations
- Async/sync boundaries are handled correctly

### Logic Correctness
- Conditional branches cover all cases
- Loop termination conditions are correct
- Mathematical operations handle precision
- State mutations are intentional
- Race conditions are prevented (concurrent code)

### Naming & Conventions
- File naming follows project pattern
- Variable/function naming is consistent (camelCase, snake_case, etc.)
- Constants use appropriate convention (UPPER_CASE, etc.)
- Boolean variables use is/has/should prefixes where conventional

### Error Handling
- Try/catch blocks are meaningful (not swallowing errors)
- Error messages are descriptive
- Cleanup/finally blocks exist where needed
- Promise/async rejections are handled

### Security
- No hardcoded credentials or secrets
- User input is sanitized
- SQL queries are parameterized
- File paths are validated
- Authentication/authorization checks exist where needed

### Code Quality
- No unreachable code
- No unused variables or imports
- Functions have single responsibility
- Magic numbers/strings are extracted to constants
- Complex logic has comments explaining "why"

### API & Interface Contracts
- Function signatures match their usage across codebase
- API endpoints match documented contracts
- Response formats are consistent
- HTTP status codes are appropriate

## Guidelines

- **Be exhaustive**: Every public function, every API endpoint, every data model gets checkpoints
- **Be specific**: "Handles null input" is better than "handles errors"
- **Be traceable**: Each checkpoint must map to specific code that can be verified in Phase 2
- **Group logically**: Module → Functionality → Checkpoints
- **Include cross-cutting concerns**: Things that span multiple modules get their own section
- **Adapt to stack**: A React project needs component lifecycle checks; a Go service needs goroutine leak checks; a Python ML project needs data pipeline checks
